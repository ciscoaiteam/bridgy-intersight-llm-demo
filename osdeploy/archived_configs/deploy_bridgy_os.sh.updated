#!/bin/bash

# Bridgy OpenShift Deployment Script
# This script handles the complete deployment of Bridgy to OpenShift:
# - Creates secrets from .env and intersight.pem files
# - Applies MongoDB resources separately (ConfigMap, Service, Deployment)
# - Applies Bridgy configuration that connects to the separate MongoDB
# - Starts build for bridgy-main using the optimized Dockerfile
# - Monitors build and deployment progress

set -e  # Exit on error

# Set up paths
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"

# Configuration
NAMESPACE="demo1"
ENV_FILE="$PROJECT_ROOT/.env"
PEM_FILE="$PROJECT_ROOT/bridgy-main/intersight.pem"
CERT_PATH="$PROJECT_ROOT/bridgy-main/cert.pem"
KEY_PATH="$PROJECT_ROOT/bridgy-main/key.pem"
SECRET_NAME="bridgy-secrets"
OUTPUT_FILE="$SCRIPT_DIR/bridgy-secrets.yaml"

# Use simple filenames for YAML resources with SCRIPT_DIR
BRIDGY_CONFIG="$SCRIPT_DIR/bridgy-optimized-deployment.yaml"
MONGODB_CONFIG="$SCRIPT_DIR/mongodb-deploymentconfig.yaml"
MONGODB_SERVICE="$SCRIPT_DIR/mongodb-service.yaml"
MONGODB_CONFIGMAP="$SCRIPT_DIR/mongodb-configmap.yaml"
MONGODB_INIT_CONFIGMAP="$SCRIPT_DIR/mongodb-init-configmap.yaml"
MONGODB_SA="$SCRIPT_DIR/mongodb-serviceaccount.yaml"
MONGODB_ROLEBINDING="$SCRIPT_DIR/mongodb-rolebinding.yaml"
BRIDGY_SERVICE="$SCRIPT_DIR/bridgy-main-service.yaml"
BRIDGY_ROUTE="$SCRIPT_DIR/bridgy-main-route.yaml"
BRIDGY_NODEPORT="$SCRIPT_DIR/bridgy-main-nodeport-service.yaml"
VLLM_SERVICE="$SCRIPT_DIR/vllm-service.yaml"
VLLM_DEPLOYMENT="$SCRIPT_DIR/vllm-deployment.yaml"
VLLM_MODELS_PVC="$SCRIPT_DIR/vllm-models-persistentvolumeclaim.yaml"
VLLM_HF_PVC="$SCRIPT_DIR/vllm-huggingface-persistentvolumeclaim.yaml"
VLLM_SA="$SCRIPT_DIR/vllm-serviceaccount.yaml"
VLLM_INIT_JOB="$SCRIPT_DIR/vllm-model-init-job.yaml"

# Parse command-line options
ONLY_VLLM=false
ONLY_FRONTEND=false
HF_TOKEN_CLI=""

while [[ $# -gt 0 ]]; do
  case "$1" in
    --only-vllm)
      ONLY_VLLM=true
      shift
      ;;
    --only-frontend)
      ONLY_FRONTEND=true
      shift
      ;;
    --hf-token)
      HF_TOKEN_CLI="$2"
      shift 2
      ;;
    *)
      echo "Unknown option: $1"
      echo "Usage: $0 [--only-vllm] [--only-frontend] [--hf-token TOKEN]"
      exit 1
      ;;
  esac
done

# Skip non-vLLM related steps if --only-vllm is specified
if [ "$ONLY_VLLM" = true ]; then
  echo "Running in vLLM-only mode - will only deploy vLLM components"
elif [ "$ONLY_FRONTEND" = true ]; then
  echo "Running in frontend-only mode - will only deploy frontend components"
else
  # Check if files exist
  if [ ! -f "$ENV_FILE" ]; then
    echo "Error: .env file not found at $ENV_FILE"
    exit 1
  fi

  if [ ! -f "$PEM_FILE" ]; then
    echo "Error: intersight.pem file not found at $PEM_FILE"
    exit 1
  fi

  if [ ! -f "$BRIDGY_CONFIG" ]; then
    echo "Error: Bridgy configuration file not found at $BRIDGY_CONFIG"
    exit 1
  fi

  # Start creating the secret YAML file
  cat > "$OUTPUT_FILE" << EOL
apiVersion: v1
kind: Secret
metadata:
  name: $SECRET_NAME
  labels:
    app: bridgy
type: Opaque
stringData:
EOL
fi

# Check OpenShift login status
echo "Checking OpenShift login status..."
oc whoami &> /dev/null
if [ $? -ne 0 ]; then
  echo "Error: You are not logged into OpenShift. Please log in first using 'oc login'."
  exit 1
fi

# Check if current project is set
CURRENT_PROJECT=$(oc project -q 2>/dev/null)
if [ -z "$CURRENT_PROJECT" ]; then
  echo "Error: No OpenShift project is selected. Please select a project with 'oc project <project-name>'."
  exit 1
fi
echo "Using project: $CURRENT_PROJECT"

# Function to safely execute commands with error handling
safe_execute() {
  echo "$ $@"
  "$@" || echo "Command failed with exit code $? (continuing anyway)"
}

# Skip non-vLLM deployment steps if --only-vllm is specified
if [ "$ONLY_VLLM" = false ] && [ "$ONLY_FRONTEND" = false ]; then
  # Cleanup old bridgy-main resources
  echo "Cleaning up old bridgy-main deployments, builds, and failed pods..."

  # First, let's get the current active deployment
  CURRENT_DC=$(oc get dc bridgy-main -o jsonpath='{.status.latestVersion}' 2>/dev/null || echo "0")
  echo "Current active deployment is: bridgy-main-$CURRENT_DC"

  # Clean up old replication controllers (which control the deployments)
  echo "Removing old bridgy-main replication controllers..."
  OLD_RCS=$(oc get rc -l app=bridgy-main | grep -v "NAME" | grep -v "bridgy-main-$CURRENT_DC" | awk '{print $1}' || true)
  if [ -n "$OLD_RCS" ]; then
    echo "Found old replication controllers to clean up:"
    for rc in $OLD_RCS; do
      echo "Deleting RC: $rc"
      safe_execute oc delete rc $rc
    done
  else
    echo "No old replication controllers found"
  fi

  # Clean up failed or completed bridgy-main deployment pods
  echo "Removing old bridgy-main deployment pods..."
  DEPLOY_PODS=$(oc get pods | grep "bridgy-main-.*-deploy" | grep -E "Completed|Error" | awk '{print $1}' || true)
  if [ -n "$DEPLOY_PODS" ]; then
    echo "Found deployment pods to clean up:"
    for pod in $DEPLOY_PODS; do
      echo "Deleting deployment pod: $pod"
      safe_execute oc delete pod $pod --force --grace-period=0
    done
  else
    echo "No old deployment pods found"
  fi

  # Clean up pods in CrashLoopBackOff state
  echo "Removing bridgy-main pods in CrashLoopBackOff state..."
  CRASHED_PODS=$(oc get pods | grep -E "bridgy-main" | grep -E "CrashLoopBackOff|Error|Completed" | grep -v "deploy" | grep -v "build" | awk '{print $1}' || true)
  if [ -n "$CRASHED_PODS" ]; then
    echo "Found pods in problem state:"
    for pod in $CRASHED_PODS; do
      echo "Deleting problem pod: $pod"
      safe_execute oc delete pod $pod --force --grace-period=0
    done
  else
    echo "No bridgy-main pods in problem state found"
  fi

  # Clean up any orphaned deployments
  echo "Cleaning up orphaned deployments..."
  ORPHANED_DEPLOYMENTS=$(oc get deployments -l app=bridgy-main 2>/dev/null | grep -v "NAME" | awk '{print $1}' || true)
  if [ -n "$ORPHANED_DEPLOYMENTS" ]; then
    echo "Found orphaned deployments:"
    for dep in $ORPHANED_DEPLOYMENTS; do
      echo "Deleting deployment: $dep"
      safe_execute oc delete deployment $dep
    done
  else
    echo "No orphaned deployments found"
  fi

  # Clean up old bridgy-main builds
  echo "Removing old bridgy-main builds..."
  # Keep the latest build, delete older ones
  OLD_BUILDS=$(oc get builds -l buildconfig=bridgy-main | grep -v "NAME" | sort -rn | tail -n +2 | awk '{print $1}' || true)
  if [ -n "$OLD_BUILDS" ]; then
    echo "Found old builds to clean up: $OLD_BUILDS"
    for build in $OLD_BUILDS; do
      safe_execute oc delete build $build
    done
  else
    echo "No old builds found"
  fi

  # Parse .env file and add entries to the secret
  echo "Adding environment variables from .env file..."
  while IFS= read -r line || [[ -n "$line" ]]; do
    # Skip comments and empty lines
    if [[ "$line" =~ ^[[:space:]]*# ]] || [[ -z "${line// }" ]]; then
      continue
    fi

    # Extract key and value (handling both KEY=value and KEY="value" formats)
    if [[ "$line" =~ ^([^=]+)=(.*)$ ]]; then
      key="${BASH_REMATCH[1]}"
      value="${BASH_REMATCH[2]}"

      # Remove quotes if present
      value="${value%\"}"
      value="${value#\"}"
      value="${value%\'}"
      value="${value#\'}"

      # Convert to kebab-case for secret keys
      secret_key=$(echo "$key" | tr '[:upper:]' '[:lower:]' | tr '_' '-')
      
      # Add to YAML with proper indentation
      echo "  $secret_key: \"$value\"" >> "$OUTPUT_FILE"
    fi
  done < "$ENV_FILE"

  # Add the intersight PEM file
  echo "Adding Intersight PEM file..."
  echo "  intersight-secret-key: |" >> "$OUTPUT_FILE"
  while IFS= read -r line || [[ -n "$line" ]]; do
    echo "    $line" >> "$OUTPUT_FILE"
  done < "$PEM_FILE"

  echo "Secret YAML file created at: $OUTPUT_FILE"
  echo "Applying secret to OpenShift cluster..."
  oc apply -f "$OUTPUT_FILE"

  # Apply MongoDB resources
  echo "Applying MongoDB service account..."
  oc apply -f "$MONGODB_SA"

  echo "Applying MongoDB role binding..."
  oc apply -f "$MONGODB_ROLEBINDING"

  echo "Applying MongoDB configmap..."
  oc apply -f "$MONGODB_CONFIGMAP"

  echo "Applying MongoDB initialization configmap..."
  oc apply -f "$MONGODB_INIT_CONFIGMAP"

  echo "Applying MongoDB service..."
  oc apply -f "$MONGODB_SERVICE"

  # Apply MongoDB data PVC
  MONGODB_DATA_PVC="$SCRIPT_DIR/mongodb-data-persistentvolumeclaim.yaml"
  echo "Applying MongoDB data PVC..."
  oc apply -f "$MONGODB_DATA_PVC"

  # Apply MongoDB deployment
  echo "Applying MongoDB deployment..."
  oc apply -f "$MONGODB_CONFIG"

  # Wait for MongoDB to start
  echo "Waiting for MongoDB to start..."
  oc rollout status dc/mongodb --timeout=180s || echo "MongoDB rollout not completed within timeout, continuing anyway..."

  # Check for and apply SSL certificates if they exist
  echo "Checking for SSL certificates..."
  SSL_CERTS_AVAILABLE=false

  if [ -f "$CERT_PATH" ] && [ -f "$KEY_PATH" ]; then
    echo "SSL certificates found. Creating ConfigMaps..."
    
    # Create ConfigMaps from certificate files
    echo "Creating ConfigMap for SSL certificate..."
    oc create configmap bridgy-ssl-cert --from-file=cert.pem="$CERT_PATH" -o yaml --dry-run=client | oc apply -f -
    
    echo "Creating ConfigMap for SSL key..."
    oc create configmap bridgy-ssl-key --from-file=key.pem="$KEY_PATH" -o yaml --dry-run=client | oc apply -f -
    
    echo "SSL certificates deployed as ConfigMaps."
    SSL_CERTS_AVAILABLE=true
  fi

  # Apply SSL configuration if needed
  if [ "$SSL_CERTS_AVAILABLE" = true ] || [ -f "$(dirname "$0")/bridgy-ssl-configmap.yaml" ]; then
    echo "Applying SSL configuration..."
    if [ -f "$(dirname "$0")/bridgy-ssl-configmap.yaml" ]; then
      oc apply -f "$(dirname "$0")/bridgy-ssl-configmap.yaml"
    fi
  fi
fi

# Apply vLLM resources if in standard or vLLM-only mode
if [ "$ONLY_FRONTEND" = false ]; then
  echo "Checking for vLLM resources..."
  if [ -f "$VLLM_MODELS_PVC" ] && [ -f "$VLLM_HF_PVC" ] && [ -f "$VLLM_SERVICE" ] && [ -f "$VLLM_DEPLOYMENT" ]; then
    echo "vLLM resources found. Applying persistent volume claims..."
    oc apply -f "$VLLM_MODELS_PVC"
    oc apply -f "$VLLM_HF_PVC"
    
    # Apply service account and RBAC for vLLM
    echo "Applying vLLM service account and RBAC..."
    oc apply -f "$VLLM_SA"
    
    echo "Applying vLLM service..."
    oc apply -f "$VLLM_SERVICE"
    
    # Parse .env file for HF_TOKEN if it exists and not provided via CLI
    HF_TOKEN="$HF_TOKEN_CLI"
    if [ -z "$HF_TOKEN" ] && [ -f "$ENV_FILE" ]; then
      HF_TOKEN=$(grep 'HF_TOKEN=' "$ENV_FILE" | sed 's/HF_TOKEN=//' | sed 's/"//g' | sed "s/'//g" || echo "")
    fi
    
    if [ -n "$HF_TOKEN" ]; then
      echo "Found Hugging Face token. Updating secret..."
      oc patch secret "$SECRET_NAME" --type=merge -p "{\"stringData\":{\"hf-token\":\"$HF_TOKEN\"}}" || oc create secret generic "$SECRET_NAME" --from-literal=hf-token="$HF_TOKEN"
    else
      echo "WARNING: Hugging Face token is required to download the Gemma 2 model."
      echo "Please create an .env file with HF_TOKEN=your_token or provide it via the --hf-token parameter."
      exit 1
    fi
    
    # Run the model initialization job
    echo "Applying vLLM model initialization job..."
    oc apply -f "$VLLM_INIT_JOB"
    
    # Wait for the initialization job to complete
    echo "Waiting for vLLM model initialization job to complete (this may take some time)..."
    oc wait --for=condition=complete --timeout=1800s job/vllm-model-init || echo "vLLM model initialization job did not complete within timeout, proceeding anyway..."
    
    # Apply vLLM deployment after the model is initialized
    echo "Applying vLLM deployment..."
    oc apply -f "$VLLM_DEPLOYMENT"
    
    USE_VLLM=true
    echo "vLLM resources applied successfully."
  else
    USE_VLLM=false
    echo "vLLM resources not found or incomplete. Skipping vLLM deployment."
  fi
fi

# Skip non-frontend deployment steps if --only-frontend is specified
if [ "$ONLY_VLLM" = false ]; then
  # Apply the Bridgy configuration if not in frontend-only mode
  if [ "$ONLY_FRONTEND" = false ]; then
    echo "Applying Bridgy optimized configuration with separated MongoDB..."
    oc apply -f "$BRIDGY_CONFIG"

    # Apply the NodePort service with correct selector
    echo "Applying Bridgy NodePort service with correct selector..."
    oc apply -f "$(dirname "$0")/bridgy-main-nodeport-service.yaml"

    # Clean up any failed builds
    echo "Cleaning up any previous failed builds..."
    # Delete builds for bridgy-main
    FAILED_BUILDS=$(oc get builds -l buildconfig=bridgy-main --no-headers | grep -E "Failed|Error|Cancelled" | awk '{print $1}' || true)
    if [ -n "$FAILED_BUILDS" ]; then
      echo "Found failed builds to clean up: $FAILED_BUILDS"
      for build in $FAILED_BUILDS; do
        safe_execute oc delete build $build
      done
    else
      echo "No failed builds found"
    fi
    # Delete build pods that belong to bridgy-main
    BUILD_PODS=$(oc get pods -l buildconfig=bridgy-main --no-headers | awk '{print $1}' || true)
    if [ -n "$BUILD_PODS" ]; then
      echo "Found build pods to clean up: $BUILD_PODS"
      for pod in $BUILD_PODS; do
        safe_execute oc delete pod $pod
      done
    else
      echo "No build pods found"
    fi

    # Delete buildconfig to ensure we're using the latest
    echo "Cleaning up existing buildconfig..."
    if oc get buildconfig bridgy-main &> /dev/null; then
      safe_execute oc delete buildconfig bridgy-main
    else
      echo "No existing buildconfig found"
    fi

    # Create a buildconfig inline since it may be missing after cleanup
    echo "Creating bridgy-main buildconfig..."
    cat <<EOF | oc apply -f -
apiVersion: build.openshift.io/v1
kind: BuildConfig
metadata:
  name: bridgy-main
  labels:
    app: bridgy-main
spec:
  source:
    type: Binary
  strategy:
    type: Docker
    dockerStrategy:
      dockerfilePath: Dockerfile
  output:
    to:
      kind: ImageStreamTag
      name: bridgy-main:latest
EOF

    # Create imagestream if it doesn't exist
    echo "Creating imagestream if it doesn't exist..."
    oc get imagestream bridgy-main || oc create imagestream bridgy-main

    # Start the binary builds
    echo ""
    echo "Preparing source directory for binary build..."

    # Create temporary directory for builds
    BUILD_DIR=$(mktemp -d)
    echo "Using temporary directory: $BUILD_DIR"

    # Prepare bridgy-main build
    echo "Preparing bridgy-main build..."
    MAIN_DIR="$BUILD_DIR/bridgy-main-build"
    mkdir -p "$MAIN_DIR"
    cp -r "$(dirname "$0")/../bridgy-main" "$MAIN_DIR"
    cp "$(dirname "$0")/../bridgy-main/Dockerfile" "$MAIN_DIR/Dockerfile"

    # Make sure the scripts are executable
    chmod +x "$MAIN_DIR/bridgy-main/verify_imports.py"
    chmod +x "$MAIN_DIR/bridgy-main/optimized_init.sh"

    # Start the build if it doesn't exist
    if ! oc get builds -l buildconfig=bridgy-main | grep -q "bridgy-main-"; then
      echo "Starting new build for bridgy-main from directory $MAIN_DIR..."
      echo "This may take several minutes. Build logs will be displayed below:"
      oc start-build bridgy-main --from-dir="$MAIN_DIR" --follow --wait=true
    else
      echo "Build already exists. Skipping."
    fi
  fi

  # Deploy frontend components (if available)
  echo "Checking for frontend components..."
  if [ -d "$(dirname "$0")/../bridgy-frontend" ]; then
    echo "Frontend components found. Setting up deployment..."
    
    # Create frontend buildconfig if it doesn't exist
    echo "Creating frontend buildconfig if it doesn't exist..."
    if ! oc get buildconfig bridgy-frontend &> /dev/null; then
      cat <<EOF | oc apply -f -
apiVersion: build.openshift.io/v1
kind: BuildConfig
metadata:
  name: bridgy-frontend
  labels:
    app: bridgy-frontend
spec:
  source:
    type: Binary
  strategy:
    type: Docker
    dockerStrategy:
      dockerfilePath: Dockerfile
  output:
    to:
      kind: ImageStreamTag
      name: bridgy-frontend:latest
EOF
    fi

    # Create imagestream if it doesn't exist
    echo "Creating frontend imagestream if it doesn't exist..."
    oc get imagestream bridgy-frontend || oc create imagestream bridgy-frontend

    # Create frontend deployment config if it doesn't exist
    echo "Creating frontend deployment if it doesn't exist..."
    if ! oc get deploymentconfig bridgy-frontend &> /dev/null; then
      cat <<EOF | oc apply -f -
apiVersion: apps.openshift.io/v1
kind: DeploymentConfig
metadata:
  name: bridgy-frontend
  labels:
    app: bridgy-frontend
spec:
  replicas: 1
  selector:
    app: bridgy-frontend
  strategy:
    type: Rolling
  template:
    metadata:
      labels:
        app: bridgy-frontend
    spec:
      containers:
      - name: bridgy-frontend
        image: image-registry.openshift-image-registry.svc:5000/demo1/bridgy-frontend:latest
        ports:
        - containerPort: 8080
          protocol: TCP
        resources:
          limits:
            memory: "256Mi"
            cpu: "500m"
          requests:
            memory: "128Mi"
            cpu: "100m"
  triggers:
  - type: ConfigChange
  - type: ImageChange
    imageChangeParams:
      automatic: true
      containerNames:
      - bridgy-frontend
      from:
        kind: ImageStreamTag
        name: bridgy-frontend:latest
        namespace: demo1
EOF
    fi

    # Create frontend service if it doesn't exist
    echo "Creating frontend service if it doesn't exist..."
    if ! oc get service bridgy-frontend &> /dev/null; then
      cat <<EOF | oc apply -f -
apiVersion: v1
kind: Service
metadata:
  name: bridgy-frontend
  labels:
    app: bridgy-frontend
spec:
  ports:
  - name: http
    port: 8080
    protocol: TCP
    targetPort: 8080
  selector:
    app: bridgy-frontend
  type: ClusterIP
EOF
    fi

    # Create frontend route if it doesn't exist
    echo "Creating frontend route if it doesn't exist..."
    if ! oc get route bridgy-frontend &> /dev/null; then
      cat <<EOF | oc apply -f -
apiVersion: route.openshift.io/v1
kind: Route
metadata:
  name: bridgy-frontend
  labels:
    app: bridgy-frontend
spec:
  port:
    targetPort: http
  to:
    kind: Service
    name: bridgy-frontend
    weight: 100
  wildcardPolicy: None
EOF
    fi

    # Prepare and build frontend if in frontend-only mode or standard mode
    echo "Preparing frontend source for build..."
    FE_DIR="$BUILD_DIR/frontend-build"
    mkdir -p "$FE_DIR"
    cp -r "$(dirname "$0")/../bridgy-frontend" "$FE_DIR"
    cp "$(dirname "$0")/../bridgy-frontend/Dockerfile" "$FE_DIR/Dockerfile"

    # Start the frontend build
    echo "Starting build for bridgy-frontend from directory $FE_DIR..."
    echo "This may take several minutes. Build logs will be displayed below:"
    oc start-build bridgy-frontend --from-dir="$FE_DIR" --follow --wait=true
  else
    echo "Frontend components not found. Skipping frontend deployment."
  fi

  # Clean up temporary build directory
  echo "Cleaning up temporary directory..."
  rm -rf "$BUILD_DIR"

  # Print final status
  echo ""
  echo "Deployment completed!"
  if [ "$ONLY_FRONTEND" = false ]; then
    echo "Main application route: $(oc get route bridgy-main -o jsonpath='{.spec.host}')"
  fi
  if [ -d "$(dirname "$0")/../bridgy-frontend" ]; then
    echo "Frontend route: $(oc get route bridgy-frontend -o jsonpath='{.spec.host}')"
  fi
  echo "vLLM server is running inside the cluster"
  echo ""
  echo "To check the status of all components, run: oc get pods"
fi

# Success!
echo "Script completed successfully."
