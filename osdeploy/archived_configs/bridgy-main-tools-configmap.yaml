apiVersion: v1
kind: ConfigMap
metadata:
  name: bridgy-main-tools
data:
  pdf_loader.py: |
    import os
    import logging
    import sys
    from typing import List
    import tempfile
    import importlib.util
    import subprocess

    # Configure logging first to capture any issues
    logging.basicConfig(level=logging.DEBUG)
    logger = logging.getLogger(__name__)

    def ensure_package_installed(package_name):
        """Ensure that a package is installed and importable"""
        try:
            # Try to import the package
            __import__(package_name)
            logger.info(f"{package_name} successfully imported")
            return True
        except ImportError as e:
            logger.error(f"Error importing {package_name}: {e}")
            # Try to install the package if missing
            try:
                logger.warning(f"Attempting to install {package_name} package...")
                subprocess.check_call([sys.executable, "-m", "pip", "install", package_name])
                logger.info(f"{package_name} installed successfully")
                # Try to import again after installation
                try:
                    __import__(package_name)
                    logger.info(f"{package_name} successfully imported after installation")
                    return True
                except ImportError:
                    logger.error(f"Still unable to import {package_name} after installation")
                    return False
            except Exception as install_error:
                logger.error(f"Failed to install {package_name}: {install_error}")
                return False

    # Now import required modules
    from langchain.text_splitter import RecursiveCharacterTextSplitter
    try:
        from langchain_community.document_loaders import PyPDFLoader
        from langchain_community.vectorstores import FAISS
        from langchain_community.embeddings import HuggingFaceEmbeddings
    except ImportError as e:
        logger.error(f"Error importing required modules: {e}")

    class PDFLoader:
        def __init__(self, pdf_dir="pdf"):
            self.pdf_dir = pdf_dir
            self.vector_store = None
            self.init_vector_store()

        def init_vector_store(self):
            """Initialize the vector store with PDF documents."""
            try:
                pdf_files = self._get_pdf_files()
                if not pdf_files:
                    logger.warning(f"No PDF files found in {self.pdf_dir}. Using mock content.")
                    self._create_mock_vector_store()
                    return

                all_docs = []
                for pdf_file in pdf_files:
                    logger.info(f"Loading PDF: {pdf_file}")
                    loader = PyPDFLoader(pdf_file)
                    docs = loader.load()
                    all_docs.extend(docs)
                    logger.info(f"Loaded {len(docs)} pages from {pdf_file}")

                if not all_docs:
                    logger.warning("No content extracted from PDFs. Using mock content.")
                    self._create_mock_vector_store()
                    return

                # Split documents into chunks
                text_splitter = RecursiveCharacterTextSplitter(
                    chunk_size=1000,
                    chunk_overlap=100
                )
                splits = text_splitter.split_documents(all_docs)
                logger.info(f"Created {len(splits)} document chunks for vectorization")

                # Create vector store using local embeddings
                embeddings = HuggingFaceEmbeddings(model_name="sentence-transformers/all-MiniLM-L6-v2")
                self.vector_store = FAISS.from_documents(splits, embeddings)
                logger.info("Vector store successfully created with real PDF content")

            except Exception as e:
                logger.error(f"Error initializing vector store: {str(e)}")
                logger.warning("Using mock content due to initialization error")
                self._create_mock_vector_store()

        def _create_mock_vector_store(self):
            """Create a mock vector store with sample data when no PDFs are available."""
            try:
                # Create temporary content
                with tempfile.NamedTemporaryFile(delete=False, suffix='.txt') as tmp:
                    tmp.write(b"This is a mock PDF content for demonstration purposes.\n")
                    tmp.write(b"It contains sample information about Cisco products.\n")
                    tmp_path = tmp.name
                
                # Split the text
                text_splitter = RecursiveCharacterTextSplitter(chunk_size=100, chunk_overlap=20)
                
                # Create a simple document structure
                class MockDocument:
                    def __init__(self, content):
                        self.page_content = content
                        self.metadata = {"source": "mock_pdf"}
                
                with open(tmp_path, 'r') as f:
                    text = f.read()
                
                mock_doc = MockDocument(text)
                chunks = text_splitter.split_documents([mock_doc])
                
                # Create the vector store
                embeddings = HuggingFaceEmbeddings(model_name="sentence-transformers/all-MiniLM-L6-v2")
                self.vector_store = FAISS.from_documents(chunks, embeddings)
                
                # Clean up
                os.unlink(tmp_path)
                logger.info("Mock vector store created successfully")
            except Exception as e:
                logger.error(f"Error creating mock vector store: {str(e)}")
                self.vector_store = None

        def _get_pdf_files(self) -> List[str]:
            """Get list of PDF files in the directory."""
            try:
                if not os.path.exists(self.pdf_dir):
                    logger.warning(f"PDF directory {self.pdf_dir} does not exist")
                    return []
                
                pdf_files = []
                for file in os.listdir(self.pdf_dir):
                    if file.lower().endswith('.pdf'):
                        pdf_path = os.path.join(self.pdf_dir, file)
                        pdf_files.append(pdf_path)
                
                logger.info(f"Found {len(pdf_files)} PDF files")
                return pdf_files
            except Exception as e:
                logger.error(f"Error getting PDF files: {str(e)}")
                return []

        def search_documents(self, query, k=3):
            """Search for documents relevant to the query."""
            try:
                if not self.vector_store:
                    logger.error("Vector store not initialized")
                    return []
                
                results = self.vector_store.similarity_search(query, k=k)
                return results
            except Exception as e:
                logger.error(f"Error searching documents: {str(e)}")
                return []
